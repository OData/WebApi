<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
using System.Collections.Generic;

namespace System.Web.OData.Query.Expressions
{
	internal abstract partial class PropertyContainer
	{
        // Entityframework requires that the two different type initializers for a given type in the same query have the same set of properties in the same order.
        // A $select=Prop1,Prop2,Prop3 where Prop1 and Prop2 are of the same type without this extra NamedPropertyWithNext type results in an select expression that looks like,
        //      c => new NamedProperty<int> { Name = "Prop1", Value = c.Prop1, Next0 = new NamedProperty<int> { Name = "Prop2", Value = c.Prop2 }, Next2 = new NamedProperty<int> { Name = "Prop3", Value = c.Prop3 } };
        // Entityframework cannot translate this expression as the first NamedProperty<int> initialization has Next and the second one doesn't. Also, Entityframework cannot 
        // create null's of NamedProperty<T>. So, you cannot generate an expression like new NamedProperty<int> { Next = null }. The exception that EF throws looks like this,
        // "The type 'NamedProperty`1[SystemInt32...]' appears in two structurally incompatible initializations within a single LINQ to Entities query. 
        // A type can be initialized in two places in the same query, but only if the same properties are set in both places and those properties are set in the same order."

	<# int levels = 32;
	string[] types = new string[] { "SingleExpandedProperty", "CollectionExpandedProperty", "AutoSelectedNamedProperty", "NamedProperty"};
	foreach(var type in types) {
	var baseClass = type;
	for(int level = 0; level < levels; level++) {
		var newClass = type + "WithNext" + level.ToString();
	#>
		private class <#= newClass #><T> : <#= baseClass #><T>
        {
            public PropertyContainer Next<#= level #> { get; set; }

            public override void ToDictionaryCore(Dictionary<string, object> dictionary, IPropertyMapper propertyMapper,
                bool includeAutoSelected)
            {
                base.ToDictionaryCore(dictionary, propertyMapper, includeAutoSelected);
                Next<#= level #>.ToDictionaryCore(dictionary, propertyMapper, includeAutoSelected);
            }
        }
	<#
	baseClass =  newClass;
	}
	
	baseClass = type;
	#>
	private static List<Type> <#= type #>Types = new List<Type> {
		typeof(<#= type #><>),
		<#
for(int level = 0; level < levels; level++) {
		var newClass = type + "WithNext" + level.ToString();
		#>
		typeof(<#= newClass #><>),
		<#
	#>
	<#}#>};
	<#
	for(int level = 0; level < levels; level++) {
	#>
		
	<#
	}
	}#>

	}
}